/**
 * P2242 公路维修问题
 *
 * 贪心策略：
 * 1. 如果所有坑都连起来修，总长度是 a[n-1] - a[0] + 1。
 * 2. 我们可以分m段修，意味着可以断开m-1个连接处（即减去m-1个间隔）。
 * 3. 为了使总长度最小，应该尽可能减去最大的间隔。
 * 4. 所以我们将相邻坑的距离算出并排序，减去最大的 m-1 个间隔即可。
 */
#include <algorithm>
#include <iostream>

int a[15005];    // 存储 n 个坑的位置
int sub[15005];  // 存储相邻坑之间的距离
int main() {
    int n, m;
    std::cin >> n >> m;

    for (int i = 0; i < n; i++) {
        std::cin >> a[i];
    }
    // 特殊情况：如果坑的数量等于路段数，每个坑单独修，总长度为 n
    if (n == m) {
        std::cout << n << std::endl;
        return 0;
    }
    // 计算相邻坑之间的距离
    for (int i = 1; i < n; i++) {
        sub[i] = a[i] - a[i - 1];
    }
    // 对距离进行从小到大排序
    std::sort(sub + 1, sub + n);

    // 初始总长度：将所有坑看作一段时的长度
    int ans = a[n - 1] - a[0] + 1;

    // 贪心：减去 m-1 个最大的间隔
    // 排序后 sub[n-1] 是最大的，sub[n-2] 次之...
    for (int i = 0; i < m - 1; i++) {
        ans -= sub[n - 1 - i];
    }

    // ans 减去的是间隔的数值 (a[i+1] - a[i])。
    // 每断开一个间隔，这就变成了两段。
    // 实际上每多一段，因为端点的包含关系，总长度相比单纯减去间隔数值要多 1。
    // 或者可以理解为：
    // 每减去一个间隔 gap，节省的长度是 gap - 1。
    // 代码中是先减去 gap，最后再统一把每段多减去的 1 加回来。
    // 共断开 m-1 次，所以最后加 m-1。
    std::cout << ans + m - 1 << std::endl;
    return 0;
}